// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.6

import { Writer, Reader, Protobuf } from "as-proto";
import { google } from "../../../google";

@unmanaged
export class AccessTypeParam {
  static encode(message: AccessTypeParam, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.value);
  }

  static decode(reader: Reader, length: i32): AccessTypeParam {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AccessTypeParam();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  value: AccessType;

  constructor(value: AccessType = 0) {
    this.value = value;
  }
}

export function encodeAccessTypeParam(message: AccessTypeParam): Uint8Array {
  return Protobuf.encode(message, AccessTypeParam.encode);
}

export function decodeAccessTypeParam(buffer: Uint8Array): AccessTypeParam {
  return Protobuf.decode<AccessTypeParam>(buffer, AccessTypeParam.decode);
}

export class AccessConfig {
  static encode(message: AccessConfig, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.permission);

    writer.uint32(18);
    writer.string(message.address);
  }

  static decode(reader: Reader, length: i32): AccessConfig {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AccessConfig();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.permission = reader.int32();
          break;

        case 2:
          message.address = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  permission: AccessType;
  address: string;

  constructor(permission: AccessType = 0, address: string = "") {
    this.permission = permission;
    this.address = address;
  }
}

export function encodeAccessConfig(message: AccessConfig): Uint8Array {
  return Protobuf.encode(message, AccessConfig.encode);
}

export function decodeAccessConfig(buffer: Uint8Array): AccessConfig {
  return Protobuf.decode<AccessConfig>(buffer, AccessConfig.decode);
}

export class Params {
  static encode(message: Params, writer: Writer): void {
    const codeUploadAccess = message.codeUploadAccess;
    if (codeUploadAccess !== null) {
      writer.uint32(10);
      writer.fork();
      AccessConfig.encode(codeUploadAccess, writer);
      writer.ldelim();
    }

    writer.uint32(16);
    writer.int32(message.instantiateDefaultPermission);
  }

  static decode(reader: Reader, length: i32): Params {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Params();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codeUploadAccess = AccessConfig.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.instantiateDefaultPermission = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  codeUploadAccess: AccessConfig | null;
  instantiateDefaultPermission: AccessType;

  constructor(
    codeUploadAccess: AccessConfig | null = null,
    instantiateDefaultPermission: AccessType = 0
  ) {
    this.codeUploadAccess = codeUploadAccess;
    this.instantiateDefaultPermission = instantiateDefaultPermission;
  }
}

export function encodeParams(message: Params): Uint8Array {
  return Protobuf.encode(message, Params.encode);
}

export function decodeParams(buffer: Uint8Array): Params {
  return Protobuf.decode<Params>(buffer, Params.decode);
}

export class CodeInfo {
  static encode(message: CodeInfo, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.codeHash);

    writer.uint32(18);
    writer.string(message.creator);

    const instantiateConfig = message.instantiateConfig;
    if (instantiateConfig !== null) {
      writer.uint32(42);
      writer.fork();
      AccessConfig.encode(instantiateConfig, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CodeInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CodeInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codeHash = reader.bytes();
          break;

        case 2:
          message.creator = reader.string();
          break;

        case 5:
          message.instantiateConfig = AccessConfig.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  codeHash: Uint8Array;
  creator: string;
  instantiateConfig: AccessConfig | null;

  constructor(
    codeHash: Uint8Array = new Uint8Array(0),
    creator: string = "",
    instantiateConfig: AccessConfig | null = null
  ) {
    this.codeHash = codeHash;
    this.creator = creator;
    this.instantiateConfig = instantiateConfig;
  }
}

export function encodeCodeInfo(message: CodeInfo): Uint8Array {
  return Protobuf.encode(message, CodeInfo.encode);
}

export function decodeCodeInfo(buffer: Uint8Array): CodeInfo {
  return Protobuf.decode<CodeInfo>(buffer, CodeInfo.decode);
}

export class ContractInfo {
  static encode(message: ContractInfo, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.codeId);

    writer.uint32(18);
    writer.string(message.creator);

    writer.uint32(26);
    writer.string(message.admin);

    writer.uint32(34);
    writer.string(message.label);

    const created = message.created;
    if (created !== null) {
      writer.uint32(42);
      writer.fork();
      AbsoluteTxPosition.encode(created, writer);
      writer.ldelim();
    }

    writer.uint32(50);
    writer.string(message.ibcPortId);

    const extension = message.extension;
    if (extension !== null) {
      writer.uint32(58);
      writer.fork();
      google.protobuf.Any.encode(extension, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ContractInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ContractInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codeId = reader.uint64();
          break;

        case 2:
          message.creator = reader.string();
          break;

        case 3:
          message.admin = reader.string();
          break;

        case 4:
          message.label = reader.string();
          break;

        case 5:
          message.created = AbsoluteTxPosition.decode(reader, reader.uint32());
          break;

        case 6:
          message.ibcPortId = reader.string();
          break;

        case 7:
          message.extension = google.protobuf.Any.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  codeId: u64;
  creator: string;
  admin: string;
  label: string;
  created: AbsoluteTxPosition | null;
  ibcPortId: string;
  extension: google.protobuf.Any | null;

  constructor(
    codeId: u64 = 0,
    creator: string = "",
    admin: string = "",
    label: string = "",
    created: AbsoluteTxPosition | null = null,
    ibcPortId: string = "",
    extension: google.protobuf.Any | null = null
  ) {
    this.codeId = codeId;
    this.creator = creator;
    this.admin = admin;
    this.label = label;
    this.created = created;
    this.ibcPortId = ibcPortId;
    this.extension = extension;
  }
}

export function encodeContractInfo(message: ContractInfo): Uint8Array {
  return Protobuf.encode(message, ContractInfo.encode);
}

export function decodeContractInfo(buffer: Uint8Array): ContractInfo {
  return Protobuf.decode<ContractInfo>(buffer, ContractInfo.decode);
}

export class ContractCodeHistoryEntry {
  static encode(message: ContractCodeHistoryEntry, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.operation);

    writer.uint32(16);
    writer.uint64(message.codeId);

    const updated = message.updated;
    if (updated !== null) {
      writer.uint32(26);
      writer.fork();
      AbsoluteTxPosition.encode(updated, writer);
      writer.ldelim();
    }

    writer.uint32(34);
    writer.bytes(message.msg);
  }

  static decode(reader: Reader, length: i32): ContractCodeHistoryEntry {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ContractCodeHistoryEntry();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.operation = reader.int32();
          break;

        case 2:
          message.codeId = reader.uint64();
          break;

        case 3:
          message.updated = AbsoluteTxPosition.decode(reader, reader.uint32());
          break;

        case 4:
          message.msg = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  operation: ContractCodeHistoryOperationType;
  codeId: u64;
  updated: AbsoluteTxPosition | null;
  msg: Uint8Array;

  constructor(
    operation: ContractCodeHistoryOperationType = 0,
    codeId: u64 = 0,
    updated: AbsoluteTxPosition | null = null,
    msg: Uint8Array = new Uint8Array(0)
  ) {
    this.operation = operation;
    this.codeId = codeId;
    this.updated = updated;
    this.msg = msg;
  }
}

export function encodeContractCodeHistoryEntry(
  message: ContractCodeHistoryEntry
): Uint8Array {
  return Protobuf.encode(message, ContractCodeHistoryEntry.encode);
}

export function decodeContractCodeHistoryEntry(
  buffer: Uint8Array
): ContractCodeHistoryEntry {
  return Protobuf.decode<ContractCodeHistoryEntry>(
    buffer,
    ContractCodeHistoryEntry.decode
  );
}

@unmanaged
export class AbsoluteTxPosition {
  static encode(message: AbsoluteTxPosition, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.blockHeight);

    writer.uint32(16);
    writer.uint64(message.txIndex);
  }

  static decode(reader: Reader, length: i32): AbsoluteTxPosition {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AbsoluteTxPosition();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockHeight = reader.uint64();
          break;

        case 2:
          message.txIndex = reader.uint64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  blockHeight: u64;
  txIndex: u64;

  constructor(blockHeight: u64 = 0, txIndex: u64 = 0) {
    this.blockHeight = blockHeight;
    this.txIndex = txIndex;
  }
}

export function encodeAbsoluteTxPosition(
  message: AbsoluteTxPosition
): Uint8Array {
  return Protobuf.encode(message, AbsoluteTxPosition.encode);
}

export function decodeAbsoluteTxPosition(
  buffer: Uint8Array
): AbsoluteTxPosition {
  return Protobuf.decode<AbsoluteTxPosition>(buffer, AbsoluteTxPosition.decode);
}

export class Model {
  static encode(message: Model, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    writer.uint32(18);
    writer.bytes(message.value);
  }

  static decode(reader: Reader, length: i32): Model {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Model();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.value = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  value: Uint8Array;

  constructor(
    key: Uint8Array = new Uint8Array(0),
    value: Uint8Array = new Uint8Array(0)
  ) {
    this.key = key;
    this.value = value;
  }
}

export function encodeModel(message: Model): Uint8Array {
  return Protobuf.encode(message, Model.encode);
}

export function decodeModel(buffer: Uint8Array): Model {
  return Protobuf.decode<Model>(buffer, Model.decode);
}

export enum AccessType {
  ACCESS_TYPE_UNSPECIFIED = 0,
  ACCESS_TYPE_NOBODY = 1,
  ACCESS_TYPE_ONLY_ADDRESS = 2,
  ACCESS_TYPE_EVERYBODY = 3,
}

export enum ContractCodeHistoryOperationType {
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3,
}
